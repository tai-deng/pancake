"use strict";
cc._RF.push(module, 'dd7c972jqtDkbyC17izJ8JQ', 'Pancake');
// Script/gameScene/Pancake.ts

Object.defineProperty(exports, "__esModule", { value: true });
var GameConfig_1 = require("../GameConfig");
// Learn TypeScript:
//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/typescript.html
//  - [English] http://www.cocos2d-x.org/docs/creator/manual/en/scripting/typescript.html
// Learn Attribute:
//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/reference/attributes.html
//  - [English] http://www.cocos2d-x.org/docs/creator/manual/en/scripting/reference/attributes.html
// Learn life-cycle callbacks:
//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/life-cycle-callbacks.html
//  - [English] http://www.cocos2d-x.org/docs/creator/manual/en/scripting/life-cycle-callbacks.html
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
/**
 * 煎饼
 */
var Pancake = /** @class */ (function (_super) {
    __extends(Pancake, _super);
    function Pancake() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.pancakeSF = null;
        //片段节点
        _this._slices = [];
        //0 静止
        //1 下落
        //2 上抛
        _this._state = 0;
        //上一次停止的时候的旋转度
        _this._lastRotation = 0;
        return _this;
    }
    Pancake_1 = Pancake;
    Pancake.prototype.start = function () {
        this.createRigidBodies();
        //中间节点
        this._centerNode = this._slices[Math.floor(this._slices.length / 2)];
    };
    /**
     * 创建结构
     *
     */
    Pancake.prototype.createRigidBodies = function () {
        //煎饼宽
        var pancakeW = 168;
        //煎饼高
        var pancakeH = 28;
        //煎饼分块数量
        var sliceCount = GameConfig_1.default.PANCAKE_SLICE_COUNT;
        // let sliceContentW:number = 4;//真实宽
        var sliceW = pancakeW / sliceCount;
        var lastSliceBody;
        var script = this;
        for (var i = 0; i < sliceCount; i++) {
            var sliceNode = new cc.Node();
            sliceNode.x = i * sliceW - pancakeW / 2;
            cc.info("====  createRigidBodies  ====");
            // let rigidBody:cc.RigidBody = sliceNode.addComponent(cc.RigidBody);
            var collider = sliceNode.addComponent(cc.PhysicsBoxCollider);
            var rigidBody = sliceNode.getComponent(cc.RigidBody);
            //类型
            // rigidBody.type = cc.RigidBodyType.Dynamic;
            rigidBody.type = cc.RigidBodyType.Static;
            //角速度衰减
            rigidBody.angularDamping = GameConfig_1.default.PANCAKE_ANGULAR_DAMPING;
            rigidBody.gravityScale = GameConfig_1.default.PANCAKE_GRAVITY_SCALE; //重力系数
            //不旋转
            // rigidBody.fixedRotation = true;
            collider.size = new cc.Size(sliceW, pancakeH);
            collider.friction = GameConfig_1.default.PANCAKE_FRICTION; //摩擦系数
            collider.restitution = GameConfig_1.default.PANCAKE_RESTITUTION; //弹性系数
            collider.apply();
            if (!lastSliceBody) {
                lastSliceBody = rigidBody;
            }
            else {
                //创建连接点
                var revoluteJoint = sliceNode.addComponent(cc.RevoluteJoint);
                revoluteJoint.anchor = new cc.Vec2(-sliceW / 2, 0);
                revoluteJoint.connectedAnchor = new cc.Vec2(sliceW / 2, 0);
                revoluteJoint.connectedBody = lastSliceBody;
                revoluteJoint.collideConnected = false; //连接的两个钢体不碰撞
                revoluteJoint.apply();
                //上头绳索
                var ropeJoint = sliceNode.addComponent(cc.RopeJoint);
                ropeJoint.anchor = new cc.Vec2(0, pancakeH / 2 - 2);
                ropeJoint.connectedAnchor = new cc.Vec2(0, pancakeH / 2 - 2);
                ropeJoint.connectedBody = lastSliceBody;
                ropeJoint.maxLength = sliceW + GameConfig_1.default.PANCAKE_BEND;
                ropeJoint.collideConnected = false;
                ropeJoint.apply();
                //下头绳索
                ropeJoint = sliceNode.addComponent(cc.RopeJoint);
                ropeJoint.anchor = new cc.Vec2(0, -pancakeH / 2 + 2);
                ropeJoint.connectedAnchor = new cc.Vec2(0, -pancakeH / 2 + 2);
                ropeJoint.connectedBody = lastSliceBody;
                ropeJoint.maxLength = sliceW + GameConfig_1.default.PANCAKE_BEND;
                ropeJoint.collideConnected = false;
                ropeJoint.apply();
                lastSliceBody = rigidBody;
            }
            //======================================================
            //监听事件
            //======================================================
            // body.fixedRotation = true;
            rigidBody.enabledContactListener = true;
            rigidBody.onBeginContact = function (contact, selfCollider, otherCollider) {
                script.onBeginContact(contact, selfCollider, otherCollider);
            };
            // rigidBody.onEndContact = function(contact:cc.PhysicsContact,selfCollider:cc.PhysicsCollider,otherCollider:cc.PhysicsCollider){
            //     script.onEndContact(contact, selfCollider, otherCollider);
            // }
            rigidBody.onPostSolve = function (contact, selfCollider, otherCollider) {
                script.onPostSolve(contact, selfCollider, otherCollider);
            };
            //======================================================
            this.node.addChild(sliceNode);
            this._slices.push(sliceNode);
        }
    };
    Object.defineProperty(Pancake.prototype, "centerNode", {
        get: function () {
            return this._centerNode;
        },
        enumerable: true,
        configurable: true
    });
    Pancake.prototype.update = function (dt) {
        var frames = cc.director.getTotalFrames();
        if (frames % 10 == 0) {
            //检查煎饼的线性速度
            var centerBody = this._centerNode.getComponent(cc.RigidBody);
            var velocity = centerBody.getWorldPoint(new cc.Vec2(0, 0), null);
            velocity = centerBody.getLinearVelocityFromWorldPoint(velocity, null);
            if (velocity) {
                // cc.info(this._state, velocity.x, velocity.y);
                //=====================================================
                //计算获得分数
                //=====================================================
                var v = this.centerNode.rotation;
                v = v - this._lastRotation;
                v = Math.abs(Math.round(v / 180));
                if (v > 0) {
                    //获得分数
                    var evt = new cc.Event(Pancake_1.EVENT_GET_SCORE, false);
                    evt["data"] = v;
                    this.node.dispatchEvent(evt);
                    this._lastRotation = this.centerNode.rotation;
                }
                //=====================================================
                //0 静止, 1 下落, 2 上抛
                var xv = Math.abs(velocity.x);
                var yv = Math.abs(velocity.y);
                if (this._state != 0 && xv < 1 && yv < 1) {
                    if (this._state == 1) {
                        //落在铁盘上
                        this.node.dispatchEvent(new cc.Event(Pancake_1.EVENT_ON_PAN, false));
                    }
                    this._state = 0;
                }
                else if (velocity.y > 5) {
                    this._state = 2;
                }
                else if (velocity.y < -5) {
                    this._state = 1;
                }
            }
        }
    };
    Object.defineProperty(Pancake.prototype, "actived", {
        get: function () {
            return this._actived;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 让煎饼掉落
     *
     */
    Pancake.prototype.active = function () {
        if (this._actived)
            return;
        this._actived = true;
        this._slices.forEach(function (ele) {
            var body = ele.getComponent(cc.RigidBody);
            body.type = cc.RigidBodyType.Dynamic;
        });
    };
    // 饼碰撞开始
    Pancake.prototype.onBeginContact = function (contact, selfCollider, otherCollider) {
        var tag = otherCollider["tag"];
        // cc.info("【Pancake onBeginContact】", tag);
        // 碰撞到锅
        if (tag != 100) {
            contact.disabled = true;
        }
        // 碰撞到钻石
        if (tag == 200) {
            cc.info(otherCollider);
            var e = new cc.Event(Pancake_1.EVENT_GET_DIAMOND, false);
            e["data"] = otherCollider.body.node;
            this.node.dispatchEvent(e);
        }
        //碰撞到墙壁
        if (tag >= 300 && tag < 400) {
            this.node.dispatchEvent(new cc.Event(Pancake_1.EVENT_DIE, false));
        }
    };
    // 饼碰撞结束
    Pancake.prototype.onEndContact = function (contact, selfCollider, otherCollider) {
        // let tag:number = otherCollider["tag"];
        // cc.info("【Pancake onEndContact】", tag);
        // // 碰撞到锅
        // if(tag == 100){
        // }
    };
    //一次接触
    Pancake.prototype.onPostSolve = function (contact, selfCollider, otherCollider) {
        var tag = otherCollider["tag"];
        cc.info("【Pancake onPostSolve】", tag);
        // 碰撞到锅
        if (tag == 100) {
            cc.info("@@@@@@@@@@@@@@@@@@@@@");
            var theBody = selfCollider.body;
            var velocity = void 0; //= theBody.getWorldPoint(new cc.Vec2(0, 0), null);
            // velocity = theBody.getLinearVelocityFromWorldPoint(velocity, null);
            // cc.info(velocity.x, velocity.y);
            velocity = theBody.linearVelocity;
            cc.info(velocity.x, velocity.y, "theBody.linearVelocity");
            // velocity.x = 100;
            if (velocity.y > 100) {
                cc.info("施加力");
                // let sc:number = 0.5;
                // theBody.applyLinearImpulse(new cc.Vec2(60 * sc, 30 * sc), new cc.Vec2(0, 0), true);
                // let velocity:cc.Vec2 = theBody.getWorldPoint(new cc.Vec2(0, 0), null);
                // velocity = theBody.getLinearVelocityFromWorldPoint(velocity, null);
                // cc.info("施加力后", velocity.x, velocity.y);
                var sc = 0.5;
                theBody.linearVelocity = new cc.Vec2(10, velocity.y * 0.9);
                velocity = theBody.linearVelocity;
                cc.info("施加力后", velocity.x, velocity.y);
            }
        }
    };
    //获取到宝石
    Pancake.EVENT_GET_DIAMOND = "getDiamond";
    //落在了铁盘上
    Pancake.EVENT_ON_PAN = "onPan";
    //死亡
    Pancake.EVENT_DIE = "die";
    //获得分数
    Pancake.EVENT_GET_SCORE = "getScore";
    __decorate([
        property(cc.SpriteFrame)
    ], Pancake.prototype, "pancakeSF", void 0);
    Pancake = Pancake_1 = __decorate([
        ccclass
    ], Pancake);
    return Pancake;
    var Pancake_1;
}(cc.Component));
exports.default = Pancake;

cc._RF.pop();