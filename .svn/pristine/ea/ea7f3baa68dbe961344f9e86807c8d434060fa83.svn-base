import GameManager from "../gamecore/managers/GameManager";
import StateManage from "../StateManage/StateManage";
import Json from "../Json/Json";
import Pancake from "./Pancake";
import GameSceneEvents from "./GameSceneEvents";
import GameEventNames from "../GameEventNames";

const {ccclass, property} = cc._decorator;


// 手臂类执行体
@ccclass
export default class ActionMain extends cc.Component {

    
    //给予手臂的力量值
    public forceValue:number = 10000;
    
    //蛋糕重力缩放。数字越大，蛋糕下落越快，上抛速度越慢
    public cakeGravityScale:number = 1.3;
    
    //煎饼初始化时，离锅底的距离
    public cakeInitDistance:number = 300;

    //钻石预制体
    @property(cc.Prefab)
    diamondPrefab:cc.Prefab = null;

    //煎饼预制体
    @property(cc.Prefab)
    pancakePrefab:cc.Prefab = null;
    
    //钻石容器
    @property(cc.Node)
    diamondContainer:cc.Node = null;
    
    
    //锅底碰撞体
    @property(cc.Node)
    panBottomNode:cc.Node = null;

    //手臂一段
    @property(cc.Node)
    theArm:cc.Node = null;


    //是否正在触摸
    private _isTouching:boolean = false;


    //煎饼
    private _pancake:cc.Node;


    onLoad(){
        StateManage.instance.on("change", this.stateChangeHandler, this);

        this.changeSkin();
    }

    start(){
        this.createNewPancake();

        //设置平板锅底相关属性
        // let panCollider:cc.PhysicsBoxCollider = this.panBottomNode.getComponent(cc.PhysicsBoxCollider);
        // panCollider.restitution = 0.2;//弹性系数
        // panCollider.friction = 0.9;//摩擦系数

        this.node.parent.on(cc.Node.EventType.TOUCH_START, this.touchStartHandler, this);
        this.node.parent.on(cc.Node.EventType.TOUCH_END, this.touchEndHandler, this);
    }


    /**
     * 创建新的蛋糕
     * 
     */
    private createNewPancake():void {
        if (this._pancake) this._pancake.removeFromParent(true);

        //删除所有钻石
        while (this._diamonds.length) {
            this._diamonds.pop().removeFromParent();
        }

        this._pancake = cc.instantiate(this.pancakePrefab);
        this._pancake.x = this.panBottomNode.x;
        this._pancake.y = this.panBottomNode.y + this.cakeInitDistance;
        this.node.addChild(this._pancake);

        //监听事件
        this._pancake.on(Pancake.EVENT_ON_PAN, this.pancakeEventsHandler, this);
        this._pancake.on(Pancake.EVENT_GET_DIAMOND, this.pancakeEventsHandler, this);
        this._pancake.on(Pancake.EVENT_GET_SCORE, this.pancakeEventsHandler, this);
        this._pancake.on(Pancake.EVENT_DIE, this.pancakeEventsHandler, this);
    }

    //宝石
    private _diamonds:Array<cc.Node> = [];

    /**
     * 创建一个新的钻石
     */
    private createNewDiamond():void {
        if (this._diamonds.length > 0) return;

        let diam:cc.Node = cc.instantiate(this.diamondPrefab);
        diam.x = this.diamondContainer.width / 2 - Math.random() * this.diamondContainer.width;
        diam.y = this.diamondContainer.height / 2 - Math.random() * this.diamondContainer.height;
        this.diamondContainer.addChild(diam);

        this._diamonds.push(diam);

        //TODO:NEXT 新宝石特效
        
    }

    /**
     * 移除宝石
     */
    private removeADiamond(diam:cc.Node):void {
        let index:number = this._diamonds.indexOf(diam);
        if (index >= 0) {
            this._diamonds.splice(index, 1);
            
            //TODO:NEXT 宝石移除特效
            diam.removeFromParent(true);
        }
    }


    //开始触摸
    private touchStartHandler(e:cc.Event):void {
        this._isTouching = true;
        this.activeCake();
    }


    // 触摸结束
    private touchEndHandler(e:cc.Event):void {
        this._isTouching = false;
    }

    /**
     * 获取饼是否已激活
     */
    public get cakeActived():boolean {
        return this._pancake.getComponent(Pancake).actived;
    }
    

    /**
     * 激活饼
     * 
     */
    public activeCake():void {
        //让煎饼落下。
        this._pancake.getComponent(Pancake).active(this.cakeGravityScale);
    }

    
    // 改变皮肤 
    private changeSkin(){
        // let resName = StateManage.instance.getData(StateManage.KEY_SKIN);
        // let res = new Json().skins;
        // let newSkin = {};
        // res.forEach(el =>{
        //     if(el["name"] == resName){
        //         newSkin = el;
        //     }
        // })
        // cc.log(resName,newSkin)

        // let currentBigArm = cc.url.raw(newSkin["bigArm"]);
        // let currentLittleArm = cc.url.raw(newSkin["lowerArm"]);
        // let currentPot = cc.url.raw(newSkin["hand"]);

        // this.arm.getChildByName("arm1").getComponent(cc.Sprite).spriteFrame.setTexture(currentBigArm);
        // this.node.getChildByName("hands").getChildByName("littleArm").getChildByName("arm2").getComponent(cc.Sprite).spriteFrame.setTexture(currentLittleArm);
        // this.node.getChildByName("hands").getChildByName("pot").getChildByName("potImg").getComponent(cc.Sprite).spriteFrame.setTexture(currentPot);
        
    }
    // 数据值监控
    private stateChangeHandler(e:cc.Event):void {
        // let key:string = StateManage.instance.lastChangedKey;
        // // 随机宝石
        // if (key == StateManage.KEY_JEWEL_STATE && StateManage.instance.jewel == 1) {
        //     this.jewels.getComponent(Jewel).create();
        // }
        // if (key == StateManage.KEY_JEWEL_STATE && StateManage.instance.jewel == 2) {
        //     this.jewels.active = false;
        // }
        // // 当前得分
        // if (key == StateManage.KEY_SCORE) {
        //     this.score.getComponent(cc.Label).string = StateManage.instance.getData(StateManage.KEY_SCORE);
        // }
        // // 换皮肤
        // if (key == StateManage.KEY_SKIN) {
        //     // this.changeSkin();
        // }
        // // 监控游戏是否结束 1 游戏结束展示页面 2 隐藏游戏结束页面
        // if (key == StateManage.KEY_ISOVER && StateManage.instance.isOver == 1) {
        //     cc.find("Canvas/over").getComponent('Over').show();
        // }else if (key == StateManage.KEY_ISOVER && StateManage.instance.isOver == 0){
        //     this.initialize(3);
        // }
    }


    /**
     * 宝石数量
     */
    private _diamondsCount:number = 0;

    public get diamondsCount():number {
        return this._diamondsCount;
    }

    /**
     * 分数
     */
    private _score:number = 0;

    public get score():number {
        return this._score;
    }



    /**
     * 
     * @param e
     */
    private pancakeEventsHandler(e:cc.Event):void {
        cc.info("【ActionMain pancakeEventsHandler】", e.type);

        let eType:string = e.type;
        switch (eType) {
            case Pancake.EVENT_ON_PAN:
                this.createNewDiamond();
                break;
            case Pancake.EVENT_GET_SCORE:
                let score:number = parseInt(e["data"]);
                if (!isNaN(score) && score > 0) {
                    cc.info("获得分数", score);

                    this._score += score;

                    //抛出事件
                    this.node.dispatchEvent(new cc.Event(GameSceneEvents.SCORE_CHANGED, true));
                }
                break;
            case Pancake.EVENT_GET_DIAMOND:
                let theDiamond:cc.Node = e["data"] as cc.Node;
                this.removeADiamond(theDiamond);
                
                this._diamondsCount++;

                //抛出事件
                this.node.dispatchEvent(new cc.Event(GameSceneEvents.DIAMONDS_CHANGED, true));
                break;
            case Pancake.EVENT_DIE:
                this.createNewPancake();
                break;
        }
    }

    update (dt) {
        //如果有触发
        if (this._isTouching) {
            let body:cc.RigidBody = this.theArm.getComponent(cc.RigidBody);
            body.applyLinearImpulse(new cc.Vec2(this.forceValue, 0), new cc.Vec2(0, 0), true);
            // body.applyForceToCenter(new cc.Vec2(this.forceValue, 0), true);
            // body.applyForce(new cc.Vec2(this.forceValue, 0), new cc.Vec2(0, 0), true);
        }

        // let frames:number = cc.director.getTotalFrames();
        // cc.info(frames, frames % 10);
        // if (frames % 10 == 0) {
        //     if (this._pancake) {
        //         let minY:number = this.panBottomNode.y + this.panBottomNode.height;

        //         cc.info(this._pancake.y, minY);
        //         if (this._pancake.y <  minY) {
        //             this.node.dispatchEvent(new cc.Event(GameSceneEvents.GAME_OVER, false));
        //         }
        //     }
        // }
    }


    onDestroy() {
        StateManage.instance.off("change", this.stateChangeHandler);
    }
}
